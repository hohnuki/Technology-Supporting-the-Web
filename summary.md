第1部 Web概論
--
**第1章 Webとは何か**<br>

Webを支える基本的な技術は**HTTP**、**URI**、**HTML**の3つである。<br>
Webは**ハイパーメディアシステム**と**分散システム**の側面を持つ。<br>
※ハイパーメディアシステム ~ 様々な情報をリンクによって結び付けて構成するシステム<br>
※分散システム ~ 複数のコンピュータに処理が冗長化されたシステム<br>
第1部のテーマはWebの技術的なバックグラウンドとアーキテクチャ。<br>

**第2章 Webの歴史**<br>

1990年にTim Berners-Leeがハイパーメディアを用いたインターネットベースの分散情報管理システムとしてのWebを提案書に書いたことがはじまり。<br>
Webの普及を一気に推し進めたのはNCSAが公開したブラウザ「Mosaic」。<br>
ハイパーメディアの側面ではシンプルな単方向リンクが、分散システムの側面ではブラウザからHTTPというシンプルなプロトコルでアクセスできる点がここまで普及した1つの理由。<br>
Roy Fieldingが博士論文で、Webのアーキテクチャスタイルを **「REST（Representational State Transfer）」** と命名した。<br>
これはHTTPは「リソースの状態（Resource State）」の「 **表現（Representation）** 」を運んでいるという主張から名づけられた。<br>
SOAPとRESTのWebの標準争い → これに勝ち多くのソフトウェアはWebを前提に。<br>


**第3章 REST ~ Webのアーキテクチャスタイル**<br>

RESTは **Webのアーキテクチャスタイル**。アーキテクチャスタイルはアーキテクチャ設計の指針であり流儀。アーキテクチャよりも抽象度が1つ上。<br>
具体的にWebはネットワークシステムのアーキテクチャスタイルで、クライアント/サーバのアーキテクチャを持つ。<br>
つまり、クライアント/サーバでもありRESTでもある。<u>素のクライアント/サーバにいくつかの制約を加えたのがREST。</u>
<dl>
  <dt>アーキテクチャスタイル</dt>
  <dd>REST</dd>
  <dt>アーキテクチャ</dt>
  <dd>ブラウザ、サーバ、プロキシ、HTTP、URI、HTML</dd>
  <dt>実装</dt>
  <dd>Apache、Firefox、Tomcat</dd>
</dl>
RESTアーキテクチャスタイルの構成<br>

- クライアント/サーバ ~ クライアントとサーバで処理を分離
- ステートレスサーバ ~ クライアントのアプリ状態をサーバで管理しない（Cookieはグレー）
- キャッシュ ~ クライアントで過去に使用したリソースを使いまわす
- 統一インターフェース ~ HTTP
- 階層化システム ~ ロードバランサでの負荷分散やプロキシでのアクセス制限など階層的に扱える
- コードオンデマンド ~ コードをサーバからダウンロードしてクライアントで実行

私たちが作るWebサービスやWeb APIがRESTfullになると、Webは全体としてより良くなる。 → RESTfullな設計を心がけよう。<br>


​
第2部 URI
--
**第4章 URIの仕様**

URIはUniform Resource Identifierの略。つまり「リソースを統一的に認識するＩＤ」<br>
URIはASCII文字に対応しているため、日本語などはエンコードされて表示される。<br>

**第5章 URIの設計**

「Cool URIs Don`t change」（クールなURIは変わらない）<br>
クールなURLにするために..
- プログラミング言語に依存した拡張子やパスを含めない
- メソッド名やセッションIDを含めない
- URIはリソースを表現する名刺にする

URIを変更するくらいならリダイレクトするほうがクール。<br>


第3部 HTTP
--
**第6章 HTTPの基本**

HTTPはTCP/IPをベースとしたプロトコルで、最新バージョンは1.1である。<br>
HTTPの名前こそハイパーテキストの転送用プロトコルだが、実際にはHTMLやXML、静止画や動画、JSプログラムなどPCで扱えるデータは大体転送できる。<br>
RESTの特徴のうち、統一インターフェース、ステートレスサーバ、キャッシュを実現している。<br>

TCP/IPとはインターネットで標準的に利用されている通信プロトコルのセット。TCPは信頼性の高いデータ転送を提供し、IPはデータのルーティングとアドレッシングを担っている。<br>
※プロトコルとは通信の各側面に関連する動作やフォーマットを定義し、通信の参加者が互いにデータを理解し、交換するための共通の基盤を提供するもの。<br>

TCP/IPの階層ごとのプロトコルは以下。
<dl>
  <dt>アプリケーションん層</dt>
  <dd>HTTP、NTP、SSH、DNS</dd>
  <dt>トランスポート層</dt>
  <dd>UDP、TCP</dd>
  <dt>インターネット層</dt>
  <dd>IP</dd>
  <dt>ネットワークインターフェース層</dt>
  <dd>イーサネット</dd>
</dl>

Webはクライアント（ブラウザ）からのリクエストをサーバ（Webサーバ）が受け取り、解析してレスポンスを返す。レスポンスをもとに目的を達成するための処理を行う。というクライアント/サーバのアーキテクチャスタイル。<br>
HTTPリスエスト・レスポンスにはフォーマットがある。
HTTPはステートレスなプロトコルなので、サーバがクライアントのアプリケーション状態を保存しない。 → **リクエストの処理に必要な情報をすべて含めてリクエストメッセージを送る。**<br>
ステートレスなアーキテクチャはスケーラビリティの面で大きな威力を発揮する。<br>

**第7章 HTTPメソッド**

HTTPメソッドは8個しかない。内訳は以下。<br>
1. **GET** ~ リソースの取得
2. **POST** ~ 子リソースの取得、リソースへのデータの追加、その他の処理
3. **PUT** ~ リソースの更新、リソースの作成
4. **DELETE** ~ リソースの削除
5. HEAD ~ リソースのヘッダの取得
6. OPTIONS ~ リソースがサポートしているメソッドの取得
7. （TRACE ~ 自分宛にリクエストメッセージを返す試験（ループバック））
8. （CONNECT ~ プロキシ動作のトンネル接続への変更）<br>
※ほとんどGETとPOSTが使用される。POSTは万能メソッド。

CRUDでいうと<u>Create（POST/PUT）Read（GET）Update（PUT）Delete（DELETE）</u>となる。<br>

ちなみにGETメソッドの実行例は以下。<br>
リクエスト
```
GET /test HTTP/1.1
Host: example.jp
```
レスポンス
```
HTTP/1.1 200 OK
Content-Type: application/xml; charset=uft-8

<test>test1<test>
```

HTTPメソッドにおけるぺき等性と安全性とは以下の内容を指す。この2つは通信エラー時にリクエストをどう回復するかにおいて重要みたい。<br>
- べき等性 ~ 何度実行しても結果が同じであるかという特性
- 安全性 ~ サーバ上のリソースの状態を変化させないという特性<br>
※GETはべき等かつ安全だが、POSTはべき等でも安全でもない。<br>

**第8章 ステータスコード**

レスポンスメッセージの１行目にあるステータスラインはプロトコルバージョン、ステータスコード、テキストフレーズから成る。以下の例では200がステータスコード。
```
HTTP/1.1 200 OK
Content-Type: application/xhtml+xml: charset=uft-8

<html xmlns="http://www.w3.org/1999/xhtml>...</html>
```

ステータスコードの分類と意味は以下。<br>
- 1xx : 処理中
- 2xx : 成功
- 3xx : リダイレクト
- 4xx : クライアントエラー
- 5xx : サーバエラー

**第9章 HTTPヘッダ**

HTTPヘッダはメッセージのボディに対する付加的な情報を表現する。<u>リソースへのアクセス認証やキャッシュの機能はヘッダで実現する。</u><br>
リクエストヘッダやレスポンスヘッダなどの種類がある。<br>

代表的なHTTPヘッダは以下。
- 日時 ~ Dateヘッダはメッセージを生成した日時を記載する
- MIMEメディアタイプ ~ Content-Typeヘッダはxmlなどのメディアタイプを指定する。charsetヘッダはuft-8などの文字コーディングを指定する。
- 言語タグ ~ Content-Languageヘッダはリソースの言語を指定する。
- コンテントネゴシエーション ~ クライアントが処理できるメディアタイプ（Acceptヘッダ）、文字エンコーディング（Accept-Charsetヘッダ）、言語（Accept-Language）をサーバに伝えるヘッダ。
- Content-Lengthとチャンク転送 ~ Content-Lengthヘッダはメッセージボディの長さを指定する。Transfer-Encodingヘッダはボディを分割して転送できるようにする。
- **認証** ~ Basic認証とDigest認証のいずれもAuthorizationヘッダにID・PASSを暗号化（Basic認証は平文）してリクエストを送信する。
- **キャッシュ** ~ Pragmaヘッダでキャッシュ可能なリソースか指定して、Expiresヘッダでキャッシュの有効期限を示す。この2つはCache-Controlヘッダで代用可能。
- 条件付きGET ~ If-Modified-Sinceヘッダでリソースの更新日時を条件にするか、If-None-MatchヘッダでリソースのETagを条件にすることで条件付きGETは実装される。
- 持続的接続 ~ ConnectionヘッダでTCPのコネクションを継続利用するか設定できる。

第4部 ハイパーメディアフォーマット
--

**第10章 HTML**

ハイパーメディアフォーマットとしてのHTMLに主眼を置く。<br>
HTML ⇒ Hypertext Markup Language。拡張子は基本的に.htmlである。<br>
HTMLのメディアタイプはSGMLベースのHTMLを指す「text/html」と、XMLベースのXHTMLを指す「application/xhtml+xml」の２つがある。<br>
HTMLの構成要素はヘッダとボディで、ブロックレベル要素で段落などを表現し、インライン要素で強調や改行などを表現する。また共通の属性としてid属性とclass属性を有する。<br>

ハイパーメディアフォーマットとしてのHTMLの特徴は以下。<br>
- < a > ~ 最も基本的なリンクの記法。アンカータグという。
```
詳細な情報は<a href="http://hoge.jp">ホゲのWebページ</a>を参照してください。
```
- < link > ~ HTMLのヘッダでWebページ同士の関係を指定するために使う。<u>CSSへのリンクなど。</u>
```
<head>
	<link rel="index" href="http://hoge.jp/index.html"/>
	<link rel="prev" href=http://hoge.jp/1.html"/>
	<link rel="next" href=http://hoge.jp/3.html"/>
</head>
```
- < img > ・ < object > ~ オブジェクトの埋め込み。ハイパーメディアなので画像・映像も埋め込める。画像の埋め込みはimgタグを、その他のオブジェクトの埋め込みにはobjectタグを利用する。
```
<img src="http://test.jp/hoge.png" alt="ホゲ"/>
<object date="http://hoge.jp/hoge.mpeg">ホゲ</object>
```
他にもフォーム（< form >）ならGETだけでなく、POSTも発行できる。<br>
またリンクの関係を表すものとして、rel属性やmicroformatsなどもある。<br>

HTMLで実現できる機能はシンプルなハイパーメディアのみだが、その効果は絶大。ハイパーメディアによるリンクとHTTP、URIの組み合わせで初めてWebが成り立つ。<br>

**第11章 microformats**

ずいぶん昔から、RDF（Resouce Description Framework）をベースとしたセマンティックなWebがWeb上の情報に意味を与え、検索エンジンやエージェントといったプログラムが利用するようになると言われてきた。<br>
そんなセマンティックなWebを地に足のついた方向に導くのがmicroformatsみたい。<br>
⇒ （ChatGPT）マイクロフォーマットは、現存するHTMLのフレームワークの中で、ウェブ上の情報に意味を与えるための簡単で実用的な方法を提供します。これは、セマンティックウェブの理念と一致しています。<br>
セマンティックウェブは、ウェブ上の情報に明確な意味を付け加えて、機械がそれを理解し処理できるようにするためのコンセプトで、その実現の一環として、RDF(Resource Description Framework)が考案されました。しかし、RDFは抽象度が高く、その導入にはかなりの労力が必要なため、一般のウェブ開発者にはなかなか受け入れられませんでした。<br>
一方で、マイクロフォーマットは既存のHTMLに簡単に追加できるため、手軽にセマンティックウェブを実現するための道具として使われてきました。HTML要素に特定のクラス名を追加するだけで、その要素が表す情報に意味を付け加えることができます。このように、マイクロフォーマットはセマンティックウェブの理念をより現実的かつ実用的なものにする役割を果たしています。<br>
ただし、マイクロフォーマットはあくまで一つの手段であり、ウェブ全体がセマンティックウェブに移行するためには、さまざまなアプローチが必要です。これには、マイクロデータやJSON-LDなどの他の技術も含まれます。<br>



**第12章 Atom**

**第13章 Atom Publishing Protocol**

**第14章 JSON**

第5部 Webサービスの設計
--